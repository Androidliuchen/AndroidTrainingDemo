//策略模式将可变的部分从程序中抽象分离成算法接口，在该接口下分别封装一系列算法实现并使他们可以相互替换，从而导致客户端程序独立于算法的改变。
原则：将不变的抽象成接口；面向接口，而不是面向实现编程；多用组合，少用继承
实现要点：
1.通过分离变化得出策略接口Strategy
2.为Strategy接口提供实现类
3.在客户抽象中有一个Strategy
4.在客户抽象中选择、组装正确的Strategy实现

优点：
1.使用组合，使框架更加灵活
2.富有弹性，可以较好的应对变化（开闭原则）
3.更好的代码复用性（相对于继承）
4.消除大量的条件语句
缺点：
1.客户代码需要了解每个策略实现的细节
2.增加了对象的数目

适用场景：
1）许多相关的类仅仅是行为差异
2）运行时选取不同的算法变体
3）通过条件语句在多个分支中选取之一


如何让鸭子飞起来？
方法1：继承
在父类中提供实现方法，子类通过继承获得父类中的飞行行为

优点：简单易用；缺点：不具有灵活性，对未来变更支持差

方法2：抽象方法
在父类中提供抽象方法，强迫子类实现自己的飞行行为

public abstract void fly();

优点：足够灵活；缺点：太麻烦，每次继承都要实现该方法，即使相同行为也要，代码重复，不具复用性（若出现bug，每个继承的类都要修改）


多用组合，少用继承！

组合（复合）：在类中增加一个私有域，引用另一个已有的类的实例，通过调用引用实例的方法从而获得新的功能

优点：足够灵活，复用代码，更易于维护；缺点：